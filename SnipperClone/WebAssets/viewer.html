<!DOCTYPE html>
<html>
<head>
    <meta charset='utf-8'>
    <title>Document Viewer</title>
    <script src='https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js'></script>
    <style>
        body { margin: 0; padding: 0; font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; }
        #container { width: 100%; height: 100vh; overflow: auto; background: #f5f5f5; }
        #viewer { text-align: center; padding: 20px; position: relative; }
        #canvas { margin: 0 auto; box-shadow: 0 2px 10px rgba(0,0,0,0.1); }
        #toolbar { position: fixed; top: 0; left: 0; right: 0; background: #333; color: white; padding: 10px; display: flex; align-items: center; gap: 10px; z-index: 100; }
        #toolbar button { background: #555; border: none; color: white; padding: 5px 10px; border-radius: 3px; cursor: pointer; }
        #toolbar button:hover { background: #666; }
        #toolbar button:disabled { background: #444; color: #888; cursor: not-allowed; }
        #pageInfo { margin-left: auto; }
        #status { position: fixed; bottom: 10px; left: 10px; background: rgba(0,0,0,0.7); color: white; padding: 5px 10px; border-radius: 3px; }
        
        #loadingOverlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0,0,0,0.7);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 1000;
        }
        
        .spinner {
            width: 40px;
            height: 40px;
            border: 4px solid #f3f3f3;
            border-top: 4px solid #3498db;
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }
        
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        
        #errorOverlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0,0,0,0.7);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 1000;
        }
        
        .error-box {
            background: white;
            padding: 20px;
            border-radius: 5px;
            text-align: center;
            max-width: 80%;
        }
        
        .error-box button {
            margin-top: 10px;
            padding: 8px 16px;
            background: #dc3545;
            color: white;
            border: none;
            border-radius: 3px;
            cursor: pointer;
        }
    </style>
</head>
<body>
    <div id="toolbar">
        <button id="prevPage" disabled>Previous</button>
        <button id="nextPage" disabled>Next</button>
        <span id="pageInfo">No document loaded</span>
    </div>
    
    <div id="container">
        <div id="viewer">
            <canvas id="canvas"></canvas>
        </div>
    </div>
    
    <div id="status">Ready</div>
    
    <div id="loadingOverlay">
        <div class="spinner"></div>
    </div>
    
    <div id="errorOverlay">
        <div class="error-box">
            <h3>Error</h3>
            <p id="errorMessage"></p>
            <button onclick="hideError()">Close</button>
        </div>
    </div>

    <script>
        // Initialize PDF.js
        pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js';
        
        let pdfDoc = null;
        let pageNum = 1;
        let pageRendering = false;
        let pageNumPending = null;
        let scale = 1.5;
        let canvas = document.getElementById('canvas');
        let ctx = canvas.getContext('2d');
        
        function showLoading() {
            document.getElementById('loadingOverlay').style.display = 'flex';
        }
        
        function hideLoading() {
            document.getElementById('loadingOverlay').style.display = 'none';
        }
        
        function showError(message) {
            document.getElementById('errorMessage').textContent = message;
            document.getElementById('errorOverlay').style.display = 'flex';
        }
        
        function hideError() {
            document.getElementById('errorOverlay').style.display = 'none';
        }
        
        function updateStatus(message) {
            document.getElementById('status').textContent = message;
        }
        
        async function renderPage(num) {
            pageRendering = true;
            
            try {
                const page = await pdfDoc.getPage(num);
                const viewport = page.getViewport({ scale });
                
                canvas.height = viewport.height;
                canvas.width = viewport.width;
                
                const renderContext = {
                    canvasContext: ctx,
                    viewport: viewport
                };
                
                await page.render(renderContext).promise;
                
                pageRendering = false;
                if (pageNumPending !== null) {
                    renderPage(pageNumPending);
                    pageNumPending = null;
                }
                
                updatePageInfo();
            } catch (error) {
                pageRendering = false;
                showError('Failed to render page: ' + error.message);
            }
        }
        
        function queueRenderPage(num) {
            if (pageRendering) {
                pageNumPending = num;
            } else {
                renderPage(num);
            }
        }
        
        function onPrevPage() {
            if (pageNum <= 1) return;
            pageNum--;
            queueRenderPage(pageNum);
        }
        
        function onNextPage() {
            if (pageNum >= pdfDoc.numPages) return;
            pageNum++;
            queueRenderPage(pageNum);
        }
        
        function updatePageInfo() {
            document.getElementById('pageInfo').textContent = pdfDoc ? 
                `Page ${pageNum} of ${pdfDoc.numPages}` : 'No document loaded';
            
            document.getElementById('prevPage').disabled = !pdfDoc || pageNum <= 1;
            document.getElementById('nextPage').disabled = !pdfDoc || pageNum >= pdfDoc.numPages;
        }
        
        async function loadDocument(base64Data, mimeType, fileName) {
            showLoading();
            updateStatus('Loading document...');
            
            try {
                if (mimeType === 'application/pdf') {
                    const data = atob(base64Data);
                    const array = new Uint8Array(data.length);
                    for (let i = 0; i < data.length; i++) {
                        array[i] = data.charCodeAt(i);
                    }
                    
                    pdfDoc = await pdfjsLib.getDocument({data: array}).promise;
                    pageNum = 1;
                    await renderPage(pageNum);
                    
                    updateStatus(`Loaded PDF: ${fileName}`);
                    window.chrome.webview.postMessage({
                        action: 'documentLoaded',
                        success: true,
                        type: 'pdf',
                        pages: pdfDoc.numPages
                    });
                } else if (mimeType.startsWith('image/')) {
                    // Clear any existing PDF document
                    pdfDoc = null;
                    updatePageInfo();
                    
                    // Load and display image
                    const img = new Image();
                    img.onload = function() {
                        canvas.width = img.width;
                        canvas.height = img.height;
                        ctx.clearRect(0, 0, canvas.width, canvas.height);
                        ctx.drawImage(img, 0, 0);
                        
                        updateStatus(`Loaded image: ${fileName}`);
                        window.chrome.webview.postMessage({
                            action: 'documentLoaded',
                            success: true,
                            type: 'image',
                            width: img.width,
                            height: img.height
                        });
                    };
                    img.onerror = function() {
                        showError('Failed to load image');
                        window.chrome.webview.postMessage({
                            action: 'documentLoaded',
                            success: false,
                            error: 'Failed to load image'
                        });
                    };
                    img.src = `data:${mimeType};base64,${base64Data}`;
                } else {
                    throw new Error(`Unsupported file type: ${mimeType}`);
                }
            } catch (error) {
                showError('Failed to load document: ' + error.message);
                window.chrome.webview.postMessage({
                    action: 'documentLoaded',
                    success: false,
                    error: error.message
                });
            } finally {
                hideLoading();
            }
        }
        
        // Set up event listeners
        document.getElementById('prevPage').addEventListener('click', onPrevPage);
        document.getElementById('nextPage').addEventListener('click', onNextPage);
        
        // Handle messages from C#
        window.chrome.webview.addEventListener('message', async function(event) {
            try {
                const message = JSON.parse(event.data);
                switch (message.action) {
                    case 'loadDocument':
                        await loadDocument(message.data, message.mimeType, message.fileName);
                        break;
                    default:
                        console.log('Unknown message action:', message.action);
                }
            } catch (error) {
                showError('Error processing message: ' + error.message);
            }
        });
        
        // Initialize viewer
        updateStatus('Ready to load document');
    </script>
</body>
</html> 